import shutil
from pathlib import Path
from typing import List

from loguru import logger
from slugify import slugify

from . import assets
from .const import (
    ADR_REPO_ABS_PATH,
    ADR_REPO_REL_PATH,
    CWD,
    STATUS_ACCEPTED,
    STATUS_PROPOSED,
)
from .content_utils import retrieve_title_status_and_date_from_madr_content_stream
from .exceptions import (
    PyadrAdrDirectoryAlreadyExistsError,
    PyadrAdrDirectoryDoesNotExistsError,
)
from .file_utils import rename_reviewed_adr_file, update_adr_title_status

try:
    import importlib.resources as pkg_resources
except ImportError:
    # Try backported to PY<37 `importlib_resources`.
    import importlib_resources as pkg_resources  # type: ignore


def init_adr_repo(force: bool = False) -> List[Path]:
    if force:
        if ADR_REPO_ABS_PATH.exists():
            logger.warning(
                f"Directory '{ADR_REPO_ABS_PATH}/' already exists. "
                f"Used '--force' option => Erasing..."
            )
            shutil.rmtree(ADR_REPO_ABS_PATH)
            logger.warning("... Erased.")

    else:
        if ADR_REPO_ABS_PATH.exists():
            logger.error(
                f"Directory '{ADR_REPO_ABS_PATH}/' already exists. "
                "You can use '--force' option to erase."
            )
            raise PyadrAdrDirectoryAlreadyExistsError()

    created_files: List[Path] = []

    ADR_REPO_ABS_PATH.mkdir(parents=True)
    logger.info(f"Created ADR repo directory './{ADR_REPO_ABS_PATH.relative_to(CWD)}'.")

    created_files.append(_init_adr_template())

    created_files.append(_init_adr_0000())

    created_files.append(_init_adr_0001())

    logger.info(f"ADR repository successfully initialised at '{ADR_REPO_ABS_PATH}/'.")

    return created_files


def _init_adr_template() -> Path:
    template_path = ADR_REPO_ABS_PATH / "template.md"

    with template_path.open("w") as f:
        f.write(pkg_resources.read_text(assets, "madr-template.md"))  # type: ignore

    logger.info(f"Copied MADR template to './{template_path.relative_to(CWD)}'.")
    return template_path


def _init_adr_0000() -> Path:
    adr_0000_filename = "0000-record-architecture-decisions.md"
    adr_0000_path = ADR_REPO_ABS_PATH / adr_0000_filename

    with adr_0000_path.open("w") as f:
        f.write(pkg_resources.read_text(assets, adr_0000_filename))  # type: ignore

    update_adr_title_status(adr_0000_path, status=STATUS_ACCEPTED)

    logger.info(f"Created ADR './{adr_0000_path.relative_to(CWD)}'.")
    return adr_0000_path


def _init_adr_0001() -> Path:
    adr_madr_filename = "XXXX-use-markdown-architectural-decision-records.md"
    adr_madr_path = ADR_REPO_ABS_PATH / adr_madr_filename

    with adr_madr_path.open("w") as f:
        f.write(pkg_resources.read_text(assets, adr_madr_filename))  # type: ignore

    renamed_adr_path = rename_reviewed_adr_file(adr_madr_path, ADR_REPO_ABS_PATH)
    update_adr_title_status(renamed_adr_path, status=STATUS_ACCEPTED)

    logger.info(f"Created ADR './{renamed_adr_path.relative_to(CWD)}'.")
    return renamed_adr_path


def verify_adr_dir_exists():
    if not ADR_REPO_ABS_PATH.exists():
        logger.error(
            f"Directory './{ADR_REPO_REL_PATH}/' does not exist. "
            "Initialise your ADR repo first."
        )
        raise PyadrAdrDirectoryDoesNotExistsError()


def new_adr(title: str) -> Path:
    adr_path = ADR_REPO_ABS_PATH / f"XXXX-{slugify(title)}.md"
    with adr_path.open("w") as f:
        f.write(pkg_resources.read_text(assets, "madr-template.md"))  # type: ignore
    update_adr_title_status(adr_path, title=title, status=STATUS_PROPOSED)
    logger.warning(f"Created ADR './{adr_path.relative_to(CWD)}'.")
    return adr_path


def generate_toc() -> Path:
    # Initialise variables
    adr_paths = sorted(ADR_REPO_ABS_PATH.glob("[0-9][0-9][0-9][0-9]-*"))

    adrs_by_status = _extract_adrs_by_status(adr_paths)

    toc_content = _build_toc_content_from_adrs_by_status(adrs_by_status)

    toc_path = ADR_REPO_ABS_PATH / "index.md"
    with toc_path.open("w") as f:
        f.writelines(toc_content)

    return toc_path


def _build_toc_content_from_adrs_by_status(adrs_by_status):
    toc_content = [
        "<!-- This file has been generated by `pyadr`. Manual changes will be "
        "erased at next generation. -->\n",
        "# Architecture Decision Records\n",
    ]
    for status in ["accepted", "rejected", "superseded", "deprecated", "non-standard"]:
        if status != "non-standard":
            toc_content.append("\n")
            toc_content.append(f"## {adrs_by_status[status]['status-title']}\n")
            toc_content.append("\n")
            if adrs_by_status[status]["adrs"]:
                toc_content.extend(adrs_by_status[status]["adrs"])
            else:
                toc_content.append("* None\n")
        else:
            toc_content.append("\n")
            toc_content.append(f"## {adrs_by_status[status]['status-title']}\n")
            if adrs_by_status[status]["adrs-by-status"]:
                for value in adrs_by_status[status]["adrs-by-status"].values():
                    toc_content.append("\n")
                    toc_content.append(f"### {value['status-title']}\n")
                    toc_content.append("\n")
                    toc_content.extend(value["adrs"])
            else:
                toc_content.append("\n")
                toc_content.append("* None\n")
    return toc_content


def _extract_adrs_by_status(adr_paths):
    adrs_by_status = {
        "accepted": {"status-title": "Accepted Records", "adrs": []},
        "rejected": {"status-title": "Rejected Records", "adrs": []},
        "superseded": {"status-title": "Superseded Records", "adrs": []},
        "deprecated": {"status-title": "Deprecated Records", "adrs": []},
        "non-standard": {
            "status-title": "Records with non-standard statuses",
            "adrs-by-status": {},
        },
    }
    for adr in adr_paths:
        with adr.open() as f:
            (
                title,
                (status, status_phrase),
                date,
            ) = retrieve_title_status_and_date_from_madr_content_stream(f)
        try:
            status_supplement = ""
            if status_phrase:
                status_supplement = f": {status} {status_phrase}"
            adrs_by_status[status]["adrs"].append(
                f"* [{title}]({ADR_REPO_REL_PATH / adr.name}){status_supplement}\n"
            )
        except KeyError:
            if status not in adrs_by_status["non-standard"]["adrs-by-status"].keys():
                adrs_by_status["non-standard"]["adrs-by-status"][status] = {
                    "status-title": f"Status `{status}`",
                    "adrs": [],
                }
            adrs_by_status["non-standard"]["adrs-by-status"][status]["adrs"].append(
                f"* [{title}]({ADR_REPO_REL_PATH / adr.name}){status_supplement}\n"
            )
        # adr_list.append(f"* [{title}]({ADR_REPO_REL_PATH / adr.name})\n")
    return adrs_by_status
